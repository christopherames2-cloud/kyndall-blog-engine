// kyndall-blog-engine/src/sanity.js
// Sanity CMS Service for creating article drafts

import { createClient } from '@sanity/client'

let client = null

/**
 * Initialize Sanity client
 */
export function initSanity(projectId, dataset, token) {
  client = createClient({
    projectId,
    dataset,
    token,
    apiVersion: '2024-01-01',
    useCdn: false,
  })
}

/**
 * Create a draft article in Sanity
 */
export async function createDraftArticle(article) {
  if (!client) throw new Error('Sanity client not initialized')
  
  // Generate unique key helper
  const generateKey = () => Math.random().toString(36).substring(2, 10)

  // Build the document
  // Note: Created as a draft in Sanity (not published)
  // Kyndall will review and click "Publish" in Sanity Studio
  const doc = {
    _type: 'article',
    
    // Basic info
    title: article.title,
    slug: {
      _type: 'slug',
      current: article.slug,
    },
    hideFromSite: false, // Will show in listings once published
    category: article.category,
    excerpt: article.excerpt,
    
    // Content sections
    introduction: ensurePortableText(article.introduction),
    mainContent: ensurePortableText(article.mainContent),
    
    // Kyndall's Take
    kyndallsTake: article.kyndallsTake ? {
      headline: article.kyndallsTake.headline || "Kyndall's Take",
      content: ensurePortableText(article.kyndallsTake.content),
      mood: article.kyndallsTake.mood || 'recommend',
    } : null,
    
    // FAQ Section (with keys)
    faqSection: (article.faqSection || []).map(faq => ({
      _type: 'faqItem',
      _key: generateKey(),
      question: faq.question,
      answer: faq.answer,
    })),
    
    // Key Takeaways (with keys)
    keyTakeaways: (article.keyTakeaways || []).map(takeaway => ({
      _type: 'takeaway',
      _key: generateKey(),
      point: takeaway.point,
      icon: takeaway.icon || 'âœ¨',
    })),
    
    // Expert Tips (with keys)
    expertTips: (article.expertTips || []).map(tip => ({
      _type: 'tip',
      _key: generateKey(),
      title: tip.title,
      description: tip.description,
      proTip: tip.proTip || null,
    })),
    
    // SEO
    seoTitle: article.seoTitle || article.title,
    seoDescription: article.seoDescription || article.excerpt,
    keywords: article.keywords || [],
    
    // Related content (references)
    relatedBlogPosts: (article.relatedBlogPosts || []).map(post => ({
      _type: 'reference',
      _ref: post._id,
      _key: generateKey(),
    })),
    relatedArticles: (article.relatedArticles || []).map(art => ({
      _type: 'reference',
      _ref: art._id,
      _key: generateKey(),
    })),
    
    // Trend source
    trendSource: article.trendSource ? {
      platform: article.trendSource.platform,
      trendingTopic: article.trendSource.trendingTopic,
      trendingScore: article.trendSource.trendingScore,
      detectedAt: article.trendSource.detectedAt,
    } : null,
    
    // Metadata
    autoGenerated: true,
    publishedAt: article.publishedAt || new Date().toISOString(),
  }

  // Create the document
  const result = await client.create(doc)
  return result
}

/**
 * Check if a topic has already been covered
 */
export async function checkIfTopicCovered(topic) {
  if (!client) throw new Error('Sanity client not initialized')
  
  const topicLower = topic.toLowerCase()
  
  // Check both articles and blog posts
  const query = `*[
    (_type == "article" || _type == "blogPost") && 
    (
      lower(title) match $searchTerm ||
      lower(excerpt) match $searchTerm
    )
  ][0...5] {
    _id,
    _type,
    title
  }`

  const results = await client.fetch(query, { searchTerm: `*${topicLower}*` })
  
  // Check for significant overlap
  for (const result of results) {
    const resultTitle = (result.title || '').toLowerCase()
    const similarity = calculateOverlap(topicLower, resultTitle)
    if (similarity > 0.5) {
      return true
    }
  }
  
  return false
}

/**
 * Get recent articles to avoid duplicates
 */
export async function getRecentArticles(days = 30) {
  if (!client) throw new Error('Sanity client not initialized')
  
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)
  
  const query = `*[_type == "article" && publishedAt > $cutoffDate] | order(publishedAt desc) {
    _id,
    title,
    category,
    "slug": slug.current,
    trendSource
  }`

  return client.fetch(query, { cutoffDate: cutoffDate.toISOString() })
}

/**
 * Get article generation stats
 */
export async function getStats() {
  if (!client) throw new Error('Sanity client not initialized')
  
  const query = `{
    "totalArticles": count(*[_type == "article"]),
    "draftArticles": count(*[_type == "article" && status == "draft"]),
    "publishedArticles": count(*[_type == "article" && status == "published"]),
    "autoGenerated": count(*[_type == "article" && autoGenerated == true]),
    "lastGenerated": *[_type == "article" && autoGenerated == true] | order(publishedAt desc)[0].publishedAt
  }`

  return client.fetch(query)
}

/**
 * Ensure content is in Portable Text format
 */
function ensurePortableText(content) {
  if (!content) return []
  if (Array.isArray(content)) {
    // Add keys if missing
    return content.map(block => ({
      ...block,
      _key: block._key || Math.random().toString(36).substring(2, 10),
      children: (block.children || []).map(child => ({
        ...child,
        _key: child._key || Math.random().toString(36).substring(2, 10),
      })),
    }))
  }
  
  // Convert string to Portable Text
  if (typeof content === 'string') {
    const paragraphs = content.split(/\n\n+/).filter(p => p.trim())
    return paragraphs.map(para => ({
      _type: 'block',
      _key: Math.random().toString(36).substring(2, 10),
      style: 'normal',
      children: [
        {
          _type: 'span',
          _key: Math.random().toString(36).substring(2, 10),
          text: para.trim(),
          marks: [],
        }
      ],
      markDefs: [],
    }))
  }
  
  return []
}

/**
 * Calculate word overlap between two strings
 */
function calculateOverlap(str1, str2) {
  const words1 = new Set(str1.split(/\s+/).filter(w => w.length > 3))
  const words2 = new Set(str2.split(/\s+/).filter(w => w.length > 3))
  
  if (words1.size === 0 || words2.size === 0) return 0
  
  let overlap = 0
  for (const word of words1) {
    if (words2.has(word)) overlap++
  }
  
  return overlap / Math.max(words1.size, words2.size)
}
