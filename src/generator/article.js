// kyndall-blog-engine/src/generator/article.js
// Generates GEO-optimized articles using Claude AI
// UPDATED: Added references generation for E-E-A-T and GEO authority signals

import Anthropic from '@anthropic-ai/sdk'
import { 
  getArticlePrompt, 
  getFAQPrompt, 
  getTakeawayPrompt, 
  getTipsPrompt, 
  getKyndallsTakePrompt,
  getReferencesPrompt  // NEW
} from './prompts.js'

let anthropic = null

function getClient() {
  if (!anthropic) {
    const apiKey = process.env.ANTHROPIC_API_KEY
    if (!apiKey) {
      throw new Error('Missing ANTHROPIC_API_KEY')
    }
    anthropic = new Anthropic({ apiKey })
  }
  return anthropic
}

/**
 * Generate a complete GEO-optimized article from a trending topic
 */
export async function generateArticle(trend) {
  const client = getClient()
  
  const topic = trend.topic || trend.title
  const platform = trend.platform
  const tags = trend.tags || []

  console.log(`      ü§ñ Generating article structure...`)

  // Step 1: Generate main article structure (includes quickAnswer)
  const mainContent = await generateMainContent(client, topic, platform, tags)
  
  // Step 2: Generate FAQ section (critical for GEO)
  console.log(`      ü§ñ Generating FAQ section...`)
  const faqSection = await generateFAQSection(client, topic, mainContent.excerpt)
  
  // Step 3: Generate Key Takeaways
  console.log(`      ü§ñ Generating key takeaways...`)
  const keyTakeaways = await generateKeyTakeaways(client, topic, mainContent.excerpt)
  
  // Step 4: Generate Expert Tips
  console.log(`      ü§ñ Generating expert tips...`)
  const expertTips = await generateExpertTips(client, topic)
  
  // Step 5: Generate Kyndall's Take
  console.log(`      ü§ñ Generating Kyndall's perspective...`)
  const kyndallsTake = await generateKyndallsTake(client, topic, platform)
  
  // Step 6: Generate References (NEW - for E-E-A-T authority)
  console.log(`      ü§ñ Finding authoritative references...`)
  const references = await generateReferences(client, topic, mainContent.excerpt, mainContent.content)

  // Determine category from content
  const category = determineCategory(topic, mainContent.content)

  return {
    title: mainContent.title,
    slug: generateSlug(mainContent.title),
    excerpt: mainContent.excerpt,
    quickAnswer: mainContent.quickAnswer,
    introduction: mainContent.introduction,
    mainContent: mainContent.content,
    faqSection,
    keyTakeaways,
    expertTips,
    kyndallsTake,
    references,  // NEW
    category,
    seoTitle: mainContent.seoTitle,
    seoDescription: mainContent.seoDescription,
    keywords: mainContent.keywords,
    status: 'draft',
    autoGenerated: true,
    publishedAt: new Date().toISOString(),
  }
}

/**
 * Generate main article content
 */
async function generateMainContent(client, topic, platform, tags) {
  const prompt = getArticlePrompt(topic, platform, tags)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 4000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseMainContentResponse(text, topic)
}

/**
 * Generate FAQ section
 */
async function generateFAQSection(client, topic, excerpt) {
  const prompt = getFAQPrompt(topic, excerpt)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 2000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseFAQResponse(text)
}

/**
 * Generate Key Takeaways
 */
async function generateKeyTakeaways(client, topic, excerpt) {
  const prompt = getTakeawayPrompt(topic, excerpt)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseTakeawaysResponse(text)
}

/**
 * Generate Expert Tips
 */
async function generateExpertTips(client, topic) {
  const prompt = getTipsPrompt(topic)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1500,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseTipsResponse(text)
}

/**
 * Generate Kyndall's Take
 */
async function generateKyndallsTake(client, topic, platform) {
  const prompt = getKyndallsTakePrompt(topic, platform)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 500,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseKyndallsTakeResponse(text)
}

/**
 * Generate References (NEW)
 * Finds authoritative sources to support article claims
 */
async function generateReferences(client, topic, excerpt, contentSummary) {
  // Create a brief summary of content for context
  const summary = typeof contentSummary === 'string' 
    ? contentSummary.substring(0, 500) 
    : 'Beauty/lifestyle article content'
  
  const prompt = getReferencesPrompt(topic, excerpt, summary)
  
  try {
    const response = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [{ role: 'user', content: prompt }],
    })

    const text = response.content[0].text
    const references = parseReferencesResponse(text)
    
    // Add dateAccessed to each reference
    const today = new Date().toISOString().split('T')[0]
    return references.map(ref => ({
      ...ref,
      dateAccessed: today
    }))
  } catch (error) {
    console.error('      ‚ö†Ô∏è Error generating references:', error.message)
    return [] // Return empty array on error - references are optional
  }
}

// ==================== RESPONSE PARSERS ====================

function parseMainContentResponse(text, topic) {
  try {
    // Try to extract JSON from the response
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return {
        title: parsed.title || topic,
        excerpt: parsed.excerpt || '',
        quickAnswer: parsed.quickAnswer || null,
        introduction: parsed.introduction || '',
        content: parsed.content || '',
        seoTitle: parsed.seoTitle || parsed.title || topic,
        seoDescription: parsed.seoDescription || parsed.excerpt || '',
        keywords: parsed.keywords || []
      }
    }
  } catch (error) {
    console.error('Error parsing main content:', error.message)
  }
  
  // Fallback
  return {
    title: topic,
    excerpt: '',
    quickAnswer: null,
    introduction: '',
    content: text,
    seoTitle: topic,
    seoDescription: '',
    keywords: []
  }
}

function parseFAQResponse(text) {
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.faqs || []
    }
  } catch (error) {
    console.error('Error parsing FAQ:', error.message)
  }
  return []
}

function parseTakeawaysResponse(text) {
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.takeaways || []
    }
  } catch (error) {
    console.error('Error parsing takeaways:', error.message)
  }
  return []
}

function parseTipsResponse(text) {
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.tips || []
    }
  } catch (error) {
    console.error('Error parsing tips:', error.message)
  }
  return []
}

function parseKyndallsTakeResponse(text) {
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return {
        headline: parsed.headline || "Kyndall's Take",
        content: parsed.content || '',
        mood: parsed.mood || 'recommend'
      }
    }
  } catch (error) {
    console.error('Error parsing Kyndall\'s Take:', error.message)
  }
  return null
}

/**
 * Parse references response (NEW)
 */
function parseReferencesResponse(text) {
  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      const refs = parsed.references || []
      
      // Validate each reference has required fields
      return refs.filter(ref => {
        if (!ref.title || !ref.publisher || !ref.url) {
          console.log(`      ‚ö†Ô∏è Skipping invalid reference: missing required fields`)
          return false
        }
        // Basic URL validation
        if (!ref.url.startsWith('http://') && !ref.url.startsWith('https://')) {
          console.log(`      ‚ö†Ô∏è Skipping invalid reference: bad URL format`)
          return false
        }
        return true
      })
    }
  } catch (error) {
    console.error('Error parsing references:', error.message)
  }
  return []
}

// ==================== HELPER FUNCTIONS ====================

function generateSlug(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .substring(0, 80)
    .replace(/-$/, '')
}

function determineCategory(topic, content) {
  const text = `${topic} ${content}`.toLowerCase()
  
  if (text.includes('skincare') || text.includes('serum') || text.includes('moisturizer') || 
      text.includes('retinol') || text.includes('sunscreen') || text.includes('acne') ||
      text.includes('skin') || text.includes('pore') || text.includes('wrinkle')) {
    return 'skincare'
  }
  
  if (text.includes('makeup') || text.includes('foundation') || text.includes('lipstick') ||
      text.includes('eyeshadow') || text.includes('mascara') || text.includes('concealer') ||
      text.includes('blush') || text.includes('contour') || text.includes('eyeliner')) {
    return 'makeup'
  }
  
  if (text.includes('hair') || text.includes('shampoo') || text.includes('conditioner') ||
      text.includes('styling') || text.includes('curls') || text.includes('blowout')) {
    return 'haircare'
  }
  
  if (text.includes('wellness') || text.includes('self-care') || text.includes('mental health') ||
      text.includes('meditation') || text.includes('routine')) {
    return 'wellness'
  }
  
  return 'lifestyle'
}

export default generateArticle
