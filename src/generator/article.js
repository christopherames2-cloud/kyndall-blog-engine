// kyndall-blog-engine/src/generator/article.js
// Generates GEO-optimized articles using Claude AI

import Anthropic from '@anthropic-ai/sdk'
import { getArticlePrompt, getFAQPrompt, getTakeawayPrompt, getTipsPrompt, getKyndallsTakePrompt } from './prompts.js'

let anthropic = null

function getClient() {
  if (!anthropic) {
    const apiKey = process.env.ANTHROPIC_API_KEY
    if (!apiKey) {
      throw new Error('Missing ANTHROPIC_API_KEY')
    }
    anthropic = new Anthropic({ apiKey })
  }
  return anthropic
}

/**
 * Generate a complete GEO-optimized article from a trending topic
 */
export async function generateArticle(trend) {
  const client = getClient()
  
  const topic = trend.topic
  const platform = trend.platform
  const tags = trend.tags || []

  console.log(`      ðŸ¤– Generating article structure...`)

  // Step 1: Generate main article structure
  const mainContent = await generateMainContent(client, topic, platform, tags)
  
  // Step 2: Generate FAQ section (critical for GEO)
  console.log(`      ðŸ¤– Generating FAQ section...`)
  const faqSection = await generateFAQSection(client, topic, mainContent.excerpt)
  
  // Step 3: Generate Key Takeaways
  console.log(`      ðŸ¤– Generating key takeaways...`)
  const keyTakeaways = await generateKeyTakeaways(client, topic, mainContent.excerpt)
  
  // Step 4: Generate Expert Tips
  console.log(`      ðŸ¤– Generating expert tips...`)
  const expertTips = await generateExpertTips(client, topic)
  
  // Step 5: Generate Kyndall's Take
  console.log(`      ðŸ¤– Generating Kyndall's perspective...`)
  const kyndallsTake = await generateKyndallsTake(client, topic, platform)

  // Determine category from content
  const category = determineCategory(topic, mainContent.content)

  return {
    title: mainContent.title,
    slug: generateSlug(mainContent.title),
    excerpt: mainContent.excerpt,
    introduction: mainContent.introduction,
    mainContent: mainContent.content,
    faqSection,
    keyTakeaways,
    expertTips,
    kyndallsTake,
    category,
    seoTitle: mainContent.seoTitle,
    seoDescription: mainContent.seoDescription,
    keywords: mainContent.keywords,
    status: 'draft',
    autoGenerated: true,
    publishedAt: new Date().toISOString(),
  }
}

/**
 * Generate main article content
 */
async function generateMainContent(client, topic, platform, tags) {
  const prompt = getArticlePrompt(topic, platform, tags)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 4000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  
  // Parse the structured response
  return parseMainContentResponse(text, topic)
}

/**
 * Generate FAQ section
 */
async function generateFAQSection(client, topic, excerpt) {
  const prompt = getFAQPrompt(topic, excerpt)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 2000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseFAQResponse(text)
}

/**
 * Generate Key Takeaways
 */
async function generateKeyTakeaways(client, topic, excerpt) {
  const prompt = getTakeawayPrompt(topic, excerpt)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseTakeawaysResponse(text)
}

/**
 * Generate Expert Tips
 */
async function generateExpertTips(client, topic) {
  const prompt = getTipsPrompt(topic)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1500,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseTipsResponse(text)
}

/**
 * Generate Kyndall's Take
 */
async function generateKyndallsTake(client, topic, platform) {
  const prompt = getKyndallsTakePrompt(topic, platform)
  
  const response = await client.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1000,
    messages: [{ role: 'user', content: prompt }],
  })

  const text = response.content[0].text
  return parseKyndallsTakeResponse(text)
}

// ==================== RESPONSE PARSERS ====================

function parseMainContentResponse(text, topic) {
  // Default values
  const result = {
    title: topic,
    excerpt: '',
    introduction: [],
    content: [],
    seoTitle: topic,
    seoDescription: '',
    keywords: [],
  }

  try {
    // Try to parse as JSON first
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return {
        title: parsed.title || topic,
        excerpt: parsed.excerpt || parsed.description || '',
        introduction: convertToPortableText(parsed.introduction || ''),
        content: convertToPortableText(parsed.content || parsed.mainContent || ''),
        seoTitle: parsed.seoTitle || parsed.title || topic,
        seoDescription: parsed.seoDescription || parsed.excerpt || '',
        keywords: parsed.keywords || [],
      }
    }
  } catch (e) {
    // Fall back to text parsing
  }

  // Parse structured text format
  const sections = {
    title: extractSection(text, 'TITLE'),
    excerpt: extractSection(text, 'EXCERPT') || extractSection(text, 'DESCRIPTION'),
    introduction: extractSection(text, 'INTRODUCTION'),
    content: extractSection(text, 'CONTENT') || extractSection(text, 'MAIN CONTENT'),
    seoTitle: extractSection(text, 'SEO TITLE'),
    seoDescription: extractSection(text, 'SEO DESCRIPTION'),
    keywords: extractSection(text, 'KEYWORDS'),
  }

  return {
    title: sections.title || topic,
    excerpt: sections.excerpt || '',
    introduction: convertToPortableText(sections.introduction || ''),
    content: convertToPortableText(sections.content || text),
    seoTitle: sections.seoTitle || sections.title || topic,
    seoDescription: sections.seoDescription || sections.excerpt || '',
    keywords: sections.keywords ? sections.keywords.split(',').map(k => k.trim()) : [],
  }
}

function parseFAQResponse(text) {
  const faqs = []
  
  try {
    // Try JSON parsing
    const jsonMatch = text.match(/\[[\s\S]*\]/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.map(item => ({
        question: item.question || item.q,
        answer: item.answer || item.a,
      })).filter(faq => faq.question && faq.answer)
    }
  } catch (e) {
    // Fall back to text parsing
  }

  // Parse Q: A: format
  const qaPairs = text.split(/(?=Q:|Question:|\d+\.)/gi)
  
  for (const pair of qaPairs) {
    const qMatch = pair.match(/(?:Q:|Question:|\d+\.)\s*(.+?)(?=A:|Answer:|$)/is)
    const aMatch = pair.match(/(?:A:|Answer:)\s*(.+?)(?=Q:|Question:|\d+\.|$)/is)
    
    if (qMatch && aMatch) {
      faqs.push({
        question: qMatch[1].trim(),
        answer: aMatch[1].trim(),
      })
    }
  }

  return faqs.slice(0, 7) // Max 7 FAQs
}

function parseTakeawaysResponse(text) {
  const takeaways = []
  const icons = ['âœ¨', 'ðŸ’¡', 'â­', 'ðŸŽ¯', 'ðŸ’•', 'ðŸ”¥', 'âœ…']
  
  try {
    // Try JSON parsing
    const jsonMatch = text.match(/\[[\s\S]*\]/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.map((item, i) => ({
        point: typeof item === 'string' ? item : (item.point || item.takeaway),
        icon: item.icon || icons[i % icons.length],
      })).filter(t => t.point)
    }
  } catch (e) {
    // Fall back to text parsing
  }

  // Parse bullet points or numbered list
  const lines = text.split(/\n/).filter(l => l.trim())
  
  for (const line of lines) {
    const cleaned = line.replace(/^[\d\-\*\â€¢\.]+\s*/, '').trim()
    if (cleaned && cleaned.length > 10 && cleaned.length < 200) {
      takeaways.push({
        point: cleaned,
        icon: icons[takeaways.length % icons.length],
      })
    }
  }

  return takeaways.slice(0, 5)
}

function parseTipsResponse(text) {
  const tips = []
  
  try {
    // Try JSON parsing
    const jsonMatch = text.match(/\[[\s\S]*\]/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return parsed.map(item => ({
        title: item.title || item.tip,
        description: item.description || item.details,
        proTip: item.proTip || item.pro_tip || null,
      })).filter(t => t.title && t.description)
    }
  } catch (e) {
    // Fall back to text parsing
  }

  // Parse structured text
  const tipBlocks = text.split(/(?=TIP \d|Tip \d|\d+\.)/gi).filter(t => t.trim())
  
  for (const block of tipBlocks) {
    const titleMatch = block.match(/(?:TIP \d:|Tip \d:|^\d+\.)\s*(.+?)(?:\n|$)/i)
    const descMatch = block.match(/(?:Description:|Details:|\n)\s*(.+?)(?=Pro Tip:|$)/is)
    const proTipMatch = block.match(/Pro Tip:\s*(.+?)$/is)
    
    if (titleMatch) {
      tips.push({
        title: titleMatch[1].trim(),
        description: descMatch ? descMatch[1].trim() : block.replace(titleMatch[0], '').trim(),
        proTip: proTipMatch ? proTipMatch[1].trim() : null,
      })
    }
  }

  return tips.slice(0, 4)
}

function parseKyndallsTakeResponse(text) {
  let headline = "Kyndall's Take"
  let content = text
  let mood = 'recommend'

  try {
    // Try JSON parsing
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0])
      return {
        headline: parsed.headline || "Kyndall's Take",
        content: convertToPortableText(parsed.content || parsed.text || text),
        mood: parsed.mood || 'recommend',
      }
    }
  } catch (e) {
    // Fall back to text parsing
  }

  // Parse structured format
  const headlineMatch = text.match(/(?:Headline:|Title:)\s*(.+?)(?:\n|$)/i)
  if (headlineMatch) {
    headline = headlineMatch[1].trim()
    content = text.replace(headlineMatch[0], '')
  }

  const moodMatch = text.match(/(?:Mood:|Tone:)\s*(\w+)/i)
  if (moodMatch) {
    mood = moodMatch[1].toLowerCase()
    content = content.replace(moodMatch[0], '')
  }

  return {
    headline,
    content: convertToPortableText(content.trim()),
    mood,
  }
}

// ==================== HELPERS ====================

function extractSection(text, sectionName) {
  const pattern = new RegExp(`${sectionName}:\\s*(.+?)(?=\\n[A-Z]+:|$)`, 'is')
  const match = text.match(pattern)
  return match ? match[1].trim() : null
}

/**
 * Convert text/markdown to Sanity Portable Text format
 * Properly handles markdown headers (##, ###) and formatting
 */
function convertToPortableText(text) {
  if (!text) return []
  if (Array.isArray(text)) return text // Already portable text
  
  const blocks = []
  
  // Split by lines first, then group into paragraphs
  const lines = text.split('\n')
  let currentParagraph = []
  
  for (const line of lines) {
    const trimmedLine = line.trim()
    
    // Check for markdown headers
    const h2Match = trimmedLine.match(/^##\s+(.+)$/)
    const h3Match = trimmedLine.match(/^###\s+(.+)$/)
    const h4Match = trimmedLine.match(/^####\s+(.+)$/)
    
    if (h2Match || h3Match || h4Match) {
      // First, flush any accumulated paragraph
      if (currentParagraph.length > 0) {
        const paraText = currentParagraph.join(' ').trim()
        if (paraText) {
          blocks.push(createBlock(paraText, 'normal'))
        }
        currentParagraph = []
      }
      
      // Add the header block
      if (h2Match) {
        blocks.push(createBlock(h2Match[1].trim(), 'h2'))
      } else if (h3Match) {
        blocks.push(createBlock(h3Match[1].trim(), 'h3'))
      } else if (h4Match) {
        blocks.push(createBlock(h4Match[1].trim(), 'h4'))
      }
    } else if (trimmedLine === '') {
      // Empty line = end of paragraph
      if (currentParagraph.length > 0) {
        const paraText = currentParagraph.join(' ').trim()
        if (paraText) {
          blocks.push(createBlock(paraText, 'normal'))
        }
        currentParagraph = []
      }
    } else {
      // Regular text line - accumulate into paragraph
      currentParagraph.push(trimmedLine)
    }
  }
  
  // Don't forget the last paragraph
  if (currentParagraph.length > 0) {
    const paraText = currentParagraph.join(' ').trim()
    if (paraText) {
      blocks.push(createBlock(paraText, 'normal'))
    }
  }
  
  return blocks
}

/**
 * Create a Portable Text block with proper structure
 * Handles inline markdown formatting (bold, italic)
 */
function createBlock(text, style) {
  const { children, markDefs } = parseInlineFormatting(text)
  
  return {
    _type: 'block',
    _key: generateKey(),
    style: style,
    markDefs: markDefs,
    children: children,
  }
}

/**
 * Parse inline markdown formatting (bold, italic) into Portable Text spans
 */
function parseInlineFormatting(text) {
  const children = []
  const markDefs = []
  
  // Pattern to match **bold**, *italic*, and [link](url)
  // Process the text segment by segment
  let remaining = text
  let lastIndex = 0
  
  // Combined pattern for bold, italic, and links
  const pattern = /(\*\*(.+?)\*\*|\*(.+?)\*|\[(.+?)\]\((.+?)\))/g
  
  let match
  let segments = []
  let lastEnd = 0
  
  while ((match = pattern.exec(text)) !== null) {
    // Add plain text before this match
    if (match.index > lastEnd) {
      segments.push({
        type: 'plain',
        text: text.slice(lastEnd, match.index)
      })
    }
    
    if (match[2]) {
      // Bold: **text**
      segments.push({
        type: 'bold',
        text: match[2]
      })
    } else if (match[3]) {
      // Italic: *text*
      segments.push({
        type: 'italic',
        text: match[3]
      })
    } else if (match[4] && match[5]) {
      // Link: [text](url)
      segments.push({
        type: 'link',
        text: match[4],
        url: match[5]
      })
    }
    
    lastEnd = match.index + match[0].length
  }
  
  // Add remaining plain text
  if (lastEnd < text.length) {
    segments.push({
      type: 'plain',
      text: text.slice(lastEnd)
    })
  }
  
  // If no formatting found, just return plain text
  if (segments.length === 0) {
    return {
      children: [{
        _type: 'span',
        _key: generateKey(),
        text: text,
        marks: []
      }],
      markDefs: []
    }
  }
  
  // Convert segments to Portable Text children
  for (const segment of segments) {
    if (segment.type === 'plain') {
      if (segment.text) {
        children.push({
          _type: 'span',
          _key: generateKey(),
          text: segment.text,
          marks: []
        })
      }
    } else if (segment.type === 'bold') {
      children.push({
        _type: 'span',
        _key: generateKey(),
        text: segment.text,
        marks: ['strong']
      })
    } else if (segment.type === 'italic') {
      children.push({
        _type: 'span',
        _key: generateKey(),
        text: segment.text,
        marks: ['em']
      })
    } else if (segment.type === 'link') {
      const linkKey = generateKey()
      markDefs.push({
        _type: 'link',
        _key: linkKey,
        href: segment.url
      })
      children.push({
        _type: 'span',
        _key: generateKey(),
        text: segment.text,
        marks: [linkKey]
      })
    }
  }
  
  return { children, markDefs }
}

function generateSlug(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 96)
}

function generateKey() {
  return Math.random().toString(36).substring(2, 10)
}

function determineCategory(topic, content) {
  const text = `${topic} ${JSON.stringify(content)}`.toLowerCase()
  
  const categories = {
    makeup: ['makeup', 'foundation', 'concealer', 'blush', 'bronzer', 'highlighter', 'mascara', 'eyeshadow', 'lipstick', 'contour', 'brow'],
    skincare: ['skincare', 'serum', 'moisturizer', 'cleanser', 'toner', 'spf', 'sunscreen', 'retinol', 'vitamin c', 'acne', 'anti-aging'],
    nails: ['nail', 'manicure', 'pedicure', 'polish', 'gel'],
    hair: ['hair', 'hairstyle', 'haircare', 'shampoo', 'conditioner'],
    fashion: ['fashion', 'outfit', 'style', 'clothing', 'accessory'],
    lifestyle: ['lifestyle', 'wellness', 'self-care', 'routine'],
  }

  let bestCategory = 'lifestyle'
  let bestScore = 0

  for (const [category, keywords] of Object.entries(categories)) {
    const score = keywords.filter(kw => text.includes(kw)).length
    if (score > bestScore) {
      bestScore = score
      bestCategory = category
    }
  }

  return bestCategory
}
